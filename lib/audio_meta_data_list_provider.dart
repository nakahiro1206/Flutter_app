import 'package:flutter/cupertino.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'audio_meta_data.dart' show AudioMetaData;
import 'handle_audio_meta_data.dart';

// dart run build_runner clean
// dart run build_runner watch
part 'audio_meta_data_list_provider.g.dart';

@riverpod
class AudioMetaDataList extends _$AudioMetaDataList {
  @override
  Future<List<AudioMetaData>> build() => Future.value([]);

  Future<void> load() async {
    update((data) async {
      state = const AsyncLoading();
      List<AudioMetaData> audioMetaDataList = await loadAudioData();
      return audioMetaDataList;
    });
  }

  void add(AudioMetaData newData) {
    update((data) async {
      state = const AsyncLoading();
      data.add(newData);
      storeAudioData(data);
      return data;
    }, onError: (error, stackTrace) {
      state = AsyncError(error, stackTrace);
      throw 'Error occurred!';
    });
  }

  void remove(int index) {
    update((data) async {
      state = const AsyncLoading();
      final AudioMetaData removed = data.removeAt(index);
      debugPrint('${removed.title} was removed');
      storeAudioData(data);
      return data;
    }, onError: (error, stackTrace) {
      state = AsyncError(error, stackTrace);
      throw 'Error occurred!';
    });
  }

  List<AudioMetaData>? fetchData() {
    // Check if the state has data and return it; otherwise return null or handle appropriately
    return state.whenData((data) => data).valueOrNull;
  }
}

// counterProvider will be generated by build_runner
